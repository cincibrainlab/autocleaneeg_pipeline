name: Release Automation

on:
  push:
    tags:
      - 'v*'  # Trigger on version tags like v1.0.0
  workflow_dispatch:
    inputs:
      version:
        description: 'Release version (e.g., 1.4.2)'
        required: true
        type: string
      release_type:
        description: 'Type of release'
        required: true
        default: 'patch'
        type: choice
        options:
          - major
          - minor
          - patch
          - beta
      create_tag:
        description: 'Create git tag'
        required: true
        default: true
        type: boolean
      publish_pypi:
        description: 'Publish to PyPI'
        required: true
        default: false
        type: boolean
      publish_docker:
        description: 'Publish Docker image'
        required: true
        default: true
        type: boolean

permissions:
  contents: write
  packages: write
  pull-requests: write

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  prepare-release:
    name: Prepare Release
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
      tag: ${{ steps.version.outputs.tag }}
      changelog: ${{ steps.changelog.outputs.changelog }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history for changelog

      - name: Set up Python 3.11
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install bump2version gitpython

      - name: Determine version
        id: version
        run: |
          if [[ "${{ github.event_name }}" == "push" && "${{ github.ref }}" == refs/tags/* ]]; then
            # Triggered by tag push
            VERSION=${GITHUB_REF#refs/tags/v}
            TAG=${GITHUB_REF#refs/tags/}
          elif [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            # Manual trigger
            VERSION="${{ github.event.inputs.version }}"
            TAG="v${VERSION}"
          else
            echo "âŒ Unknown trigger for release workflow"
            exit 1
          fi
          
          echo "Version: $VERSION"
          echo "Tag: $TAG"
          
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "tag=$TAG" >> $GITHUB_OUTPUT

      - name: Validate version format
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          
          # Check semantic versioning format
          if [[ ! $VERSION =~ ^[0-9]+\.[0-9]+\.[0-9]+(-[a-zA-Z0-9]+)?$ ]]; then
            echo "âŒ Invalid version format: $VERSION"
            echo "Expected format: X.Y.Z or X.Y.Z-suffix"
            exit 1
          fi
          
          echo "âœ… Version format valid: $VERSION"

      - name: Update version in files
        if: github.event.inputs.create_tag == 'true'
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          
          # Update version in pyproject.toml
          sed -i "s/^version = .*/version = \"$VERSION\"/" pyproject.toml
          
          # Update version in __init__.py if it exists
          if [ -f "src/autoclean/__init__.py" ]; then
            sed -i "s/__version__ = .*/__version__ = \"$VERSION\"/" src/autoclean/__init__.py
          fi
          
          echo "âœ… Version updated in project files"

      - name: Generate changelog
        id: changelog
        run: |
          python -c "
          import subprocess
          import re
          from datetime import datetime
          
          version = '${{ steps.version.outputs.version }}'
          tag = '${{ steps.version.outputs.tag }}'
          
          # Get commits since last tag
          try:
              last_tag = subprocess.check_output(['git', 'describe', '--tags', '--abbrev=0', 'HEAD~1'], 
                                                stderr=subprocess.DEVNULL).decode().strip()
              commit_range = f'{last_tag}..HEAD'
          except:
              # No previous tags, get all commits
              commit_range = 'HEAD'
          
          # Get commit messages
          commits = subprocess.check_output(['git', 'log', '--pretty=format:%s', commit_range]).decode().strip()
          
          if not commits:
              print('No new commits for changelog')
              changelog = f'## {version} ({datetime.now().strftime(\"%Y-%m-%d\")})\n\nNo changes in this release.\n'
          else:
              commit_lines = commits.split('\n')
              
              # Categorize commits
              features = []
              fixes = []
              improvements = []
              other = []
              
              for commit in commit_lines:
                  if not commit.strip():
                      continue
                  
                  lower_commit = commit.lower()
                  if any(keyword in lower_commit for keyword in ['feat:', 'feature:', 'add']):
                      features.append(commit)
                  elif any(keyword in lower_commit for keyword in ['fix:', 'bug:', 'patch:']):
                      fixes.append(commit)
                  elif any(keyword in lower_commit for keyword in ['improve:', 'enhance:', 'update:']):
                      improvements.append(commit)
                  else:
                      other.append(commit)
              
              # Generate changelog
              changelog = f'## {version} ({datetime.now().strftime(\"%Y-%m-%d\")})\n\n'
              
              if features:
                  changelog += '### âœ¨ New Features\n'
                  for feature in features:
                      changelog += f'- {feature}\n'
                  changelog += '\n'
              
              if improvements:
                  changelog += '### ğŸš€ Improvements\n'
                  for improvement in improvements:
                      changelog += f'- {improvement}\n'
                  changelog += '\n'
              
              if fixes:
                  changelog += '### ğŸ› Bug Fixes\n'
                  for fix in fixes:
                      changelog += f'- {fix}\n'
                  changelog += '\n'
              
              if other:
                  changelog += '### ğŸ“ Other Changes\n'
                  for change in other:
                      changelog += f'- {change}\n'
                  changelog += '\n'
          
          # Save changelog
          with open('RELEASE_CHANGELOG.md', 'w') as f:
              f.write(changelog)
          
          print('âœ… Changelog generated')
          print(changelog)
          "

      - name: Create tag
        if: github.event.inputs.create_tag == 'true' && github.event_name == 'workflow_dispatch'
        run: |
          TAG="${{ steps.version.outputs.tag }}"
          VERSION="${{ steps.version.outputs.version }}"
          
          # Configure git
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          # Commit version changes
          git add pyproject.toml src/autoclean/__init__.py || true
          git commit -m "Bump version to $VERSION" || echo "No changes to commit"
          
          # Create annotated tag
          git tag -a "$TAG" -m "Release $VERSION"
          
          # Push changes and tag
          git push origin main
          git push origin "$TAG"
          
          echo "âœ… Tag $TAG created and pushed"

      - name: Upload changelog
        uses: actions/upload-artifact@v4
        with:
          name: release-changelog
          path: RELEASE_CHANGELOG.md
          retention-days: 30

  run-tests:
    name: Release Tests
    runs-on: ${{ matrix.os }}
    needs: prepare-release
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]
        python-version: ["3.10", "3.11", "3.12"]
        exclude:
          - os: macos-latest
            python-version: "3.10"
          - os: windows-latest
            python-version: "3.10"
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python ${{ matrix.python-version }}
        uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python-version }}

      - name: Install system dependencies (Ubuntu)
        if: matrix.os == 'ubuntu-latest'
        run: |
          sudo apt-get update
          sudo apt-get install -y libblas-dev liblapack-dev gfortran

      - name: Install system dependencies (macOS)
        if: matrix.os == 'macos-latest'
        run: |
          brew install openblas lapack

      - name: Install Python dependencies
        run: |
          python -m pip install --upgrade pip wheel setuptools
          pip install pytest pytest-cov
          pip install -e .

      - name: Generate test data
        run: |
          python -c "
          from tests.fixtures.synthetic_data import generate_all_test_data
          generate_all_test_data()
          "

      - name: Run critical tests
        run: |
          pytest tests/unit/core/ tests/unit/utils/ \
            -v \
            --tb=short \
            --maxfail=5

  build-package:
    name: Build Python Package
    runs-on: ubuntu-latest
    needs: [prepare-release, run-tests]
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python 3.11
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install build dependencies
        run: |
          python -m pip install --upgrade pip
          pip install build twine

      - name: Build package
        run: |
          python -m build

      - name: Check package
        run: |
          twine check dist/*

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: python-package
          path: dist/
          retention-days: 30

  build-docker:
    name: Build Docker Image
    runs-on: ubuntu-latest
    needs: [prepare-release, run-tests]
    if: github.event.inputs.publish_docker == 'true' || github.event_name == 'push'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=semver,pattern={{major}}
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          platforms: linux/amd64,linux/arm64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  publish-pypi:
    name: Publish to PyPI
    runs-on: ubuntu-latest
    needs: [prepare-release, run-tests, build-package]
    if: github.event.inputs.publish_pypi == 'true' && github.event_name == 'workflow_dispatch'
    environment: pypi
    
    steps:
      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: python-package
          path: dist/

      - name: Publish to PyPI
        uses: pypa/gh-action-pypi-publish@release/v1
        with:
          user: __token__
          password: ${{ secrets.PYPI_API_TOKEN }}
          verbose: true

  create-github-release:
    name: Create GitHub Release
    runs-on: ubuntu-latest
    needs: [prepare-release, run-tests, build-package]
    if: always() && needs.prepare-release.result == 'success'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download changelog
        uses: actions/download-artifact@v4
        with:
          name: release-changelog

      - name: Download package
        uses: actions/download-artifact@v4
        with:
          name: python-package
          path: dist/

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ needs.prepare-release.outputs.tag }}
          name: Release ${{ needs.prepare-release.outputs.version }}
          body_path: RELEASE_CHANGELOG.md
          draft: false
          prerelease: ${{ contains(needs.prepare-release.outputs.version, '-') }}
          files: |
            dist/*
          generate_release_notes: true

  post-release:
    name: Post-Release Actions
    runs-on: ubuntu-latest
    needs: [prepare-release, create-github-release]
    if: always() && needs.create-github-release.result == 'success'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Update changelog file
        run: |
          # Download the release changelog
          if [ -f "RELEASE_CHANGELOG.md" ]; then
            # Prepend to existing CHANGELOG.md
            if [ -f "CHANGELOG.md" ]; then
              echo -e "$(cat RELEASE_CHANGELOG.md)\n$(cat CHANGELOG.md)" > CHANGELOG.md
            else
              mv RELEASE_CHANGELOG.md CHANGELOG.md
            fi
            
            echo "âœ… Changelog updated"
          fi

      - name: Create post-release PR
        uses: peter-evans/create-pull-request@v5
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          commit-message: "Post-release updates for ${{ needs.prepare-release.outputs.version }}"
          title: "Post-release updates for ${{ needs.prepare-release.outputs.version }}"
          body: |
            Automated post-release updates for version ${{ needs.prepare-release.outputs.version }}
            
            This PR includes:
            - Updated CHANGELOG.md with release notes
            - Any post-release cleanup
            
            ğŸ¤– This PR was created automatically by the release workflow.
          branch: post-release/${{ needs.prepare-release.outputs.version }}
          base: main

      - name: Notify on success
        run: |
          echo "ğŸ‰ Release ${{ needs.prepare-release.outputs.version }} completed successfully!"
          echo "ğŸ“¦ Package: Published to PyPI (if enabled)"
          echo "ğŸ³ Docker: Published to GitHub Container Registry (if enabled)"
          echo "ğŸ“‹ GitHub Release: Created with changelog and artifacts"

  release-failure:
    name: Handle Release Failure
    runs-on: ubuntu-latest
    needs: [prepare-release, run-tests, build-package, create-github-release]
    if: always() && (needs.run-tests.result == 'failure' || needs.build-package.result == 'failure')
    
    steps:
      - name: Report failure
        run: |
          echo "âŒ Release process failed!"
          echo "ğŸ” Check the following jobs for errors:"
          echo "  - Tests: ${{ needs.run-tests.result }}"
          echo "  - Package Build: ${{ needs.build-package.result }}"
          echo "  - GitHub Release: ${{ needs.create-github-release.result }}"
          
          # You could add notification steps here (Slack, email, etc.)
          
          exit 1